#include <16F1827.h>
#fuses INTRC_IO, NOWDT, NOMCLR, NOPUT, NOBROWNOUT, NOCPD, NOLVP
#use delay(clock=16000000)

#define LED_VERDADERO PIN_A0
#define LED_FALSO PIN_A1

// Clave correcta
const char password[] = "1234";  
#define PASSWORD_LENGTH 4

// Variables de entrada
char input_code[PASSWORD_LENGTH + 1]; 
int8 input_length = 0;
int16 inactivity_counter = 0; // cuenta en ticks de 10ms

#define TIMEOUT_TICKS 300  // 300*10ms = 3 segundos

// Keypad pines
#define COL_1 PIN_B1
#define COL_2 PIN_B2
#define COL_3 PIN_B3
#define ROW_A PIN_B4
#define ROW_B PIN_B5
#define ROW_C PIN_B6
#define ROW_D PIN_B7 

char keymap[4][3] = {
    {'1','2','3'},
    {'4','5','6'},
    {'7','8','9'},
    {'*','0','#'}
};

// Timer0 ISR: cada ~10ms
#INT_TIMER0
void timer0_isr() {
    inactivity_counter++;
}

void init_keypad() {
    set_tris_b(0b00001110); // RB1-3 entradas, RB4-7 salidas
    output_high(ROW_A);
    output_high(ROW_B);
    output_high(ROW_C);
    output_high(ROW_D);
}

int8 read_keypad() {
    int row, col;
    int8 key = -1; // -1 = sin tecla

    for (row = 0; row < 4; row++) {
        output_high(ROW_A);
        output_high(ROW_B);
        output_high(ROW_C);
        output_high(ROW_D);

        switch(row) {
            case 0: output_low(ROW_A); break;
            case 1: output_low(ROW_B); break;
            case 2: output_low(ROW_C); break;
            case 3: output_low(ROW_D); break;
        }
        delay_us(50);

        if (!input(COL_1)) col = 0;
        else if (!input(COL_2)) col = 1;
        else if (!input(COL_3)) col = 2;
        else continue;

        delay_ms(20);
        if(!input((col==0)?COL_1 : (col==1)?COL_2 : COL_3)) {
            key = keymap[row][col];
            while(!input((col==0)?COL_1 : (col==1)?COL_2 : COL_3));
        }
        break;
    }
    return key;
}

// Reinicia el buffer
void reset_input() {
    input_length = 0;
    input_code[0] = '\0';
    inactivity_counter = 0;
}

void main() {
    int8 key_pressed = -1;
    init_keypad();
    set_tris_a(0b11111100);   // RA0 y RA1 salidas

    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256); 
    set_timer0(0);
    enable_interrupts(INT_TIMER0);
    enable_interrupts(GLOBAL);

    reset_input();

    while(TRUE) {
        // Si pasó demasiado tiempo sin tecla ? reset
        if (inactivity_counter >= TIMEOUT_TICKS) {
            reset_input();
        }

        key_pressed = read_keypad();

        if (key_pressed != -1) {
            inactivity_counter = 0; // reinicia tiempo de espera
            if (key_pressed >= '0' && key_pressed <= '9') {
                if (input_length < PASSWORD_LENGTH) {
                    input_code[input_length++] = key_pressed;
                    input_code[input_length] = '\0'; // null terminator
                }
            }
            
            // Si se completó la clave
            if (input_length == PASSWORD_LENGTH) {
                if (strcmp(input_code, password) == 0) {
                    output_high(LED_VERDADERO);
                    delay_ms(500);
                    output_low(LED_VERDADERO);
                } else {
                    output_high(LED_FALSO);
                    delay_ms(500);
                    output_low(LED_FALSO);
                }
                reset_input();
            }
        }
    }
}

