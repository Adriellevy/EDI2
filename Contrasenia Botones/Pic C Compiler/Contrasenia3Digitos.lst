CCS PCM C Compiler, Version 5.093, 4770               12-ago-25 13:56

               Filename:   C:\Users\adrie\OneDrive\Escritorio\EDI2\Contrasenia Botones\Pic C Compiler\Contrasenia3Digitos.lst

               ROM used:   368 words (9%)
                           Largest free fragment is 2048
               RAM used:   13 (3%) at main() level
                           27 (7%) worst case
               Stack used: 1 locations
               Stack size: 16

0000:  MOVLP  00
0001:  GOTO   0F0
0002:  NOP
.................... #include <16F1827.h>
.................... //////////// Standard Header file for the PIC16F1827 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F1827
0003:  BRW
0004:  RETLW  01
0005:  RETLW  02
0006:  RETLW  03
0007:  RETLW  04
0008:  RETLW  05
0009:  RETLW  06
000A:  RETLW  07
000B:  RETLW  08
000C:  RETLW  09
000D:  RETLW  FE
000E:  RETLW  00
000F:  RETLW  FD
*
002F:  CLRF   77
0030:  CLRF   78
0031:  MOVF   2A,W
0032:  BCF    03.0
0033:  BTFSC  2B.0
0034:  ADDWF  77,F
0035:  RRF    77,F
0036:  RRF    78,F
0037:  BTFSC  2B.1
0038:  ADDWF  77,F
0039:  RRF    77,F
003A:  RRF    78,F
003B:  BTFSC  2B.2
003C:  ADDWF  77,F
003D:  RRF    77,F
003E:  RRF    78,F
003F:  BTFSC  2B.3
0040:  ADDWF  77,F
0041:  RRF    77,F
0042:  RRF    78,F
0043:  BTFSC  2B.4
0044:  ADDWF  77,F
0045:  RRF    77,F
0046:  RRF    78,F
0047:  BTFSC  2B.5
0048:  ADDWF  77,F
0049:  RRF    77,F
004A:  RRF    78,F
004B:  BTFSC  2B.6
004C:  ADDWF  77,F
004D:  RRF    77,F
004E:  RRF    78,F
004F:  BTFSC  2B.7
0050:  ADDWF  77,F
0051:  RRF    77,F
0052:  RRF    78,F
0053:  RETURN
*
00C1:  BCF    0A.0
00C2:  BCF    0A.1
00C3:  BCF    0A.2
00C4:  ADDWF  02,F
00C5:  GOTO   070
00C6:  GOTO   076
00C7:  GOTO   07C
00C8:  GOTO   082
.................... 
.................... #list
.................... 
.................... #fuses INTRC_IO, NOWDT, NOMCLR, NOPUT, NOBROWNOUT, NOCPD, NOLVP
.................... #use delay(clock=16000000)
*
00DA:  MOVLW  20
00DB:  MOVWF  05
00DC:  MOVLW  09
00DD:  MOVWF  04
00DE:  MOVF   00,W
00DF:  BTFSC  03.2
00E0:  GOTO   0EF
00E1:  MOVLW  05
00E2:  MOVWF  78
00E3:  CLRF   77
00E4:  DECFSZ 77,F
00E5:  GOTO   0E4
00E6:  DECFSZ 78,F
00E7:  GOTO   0E3
00E8:  MOVLW  2E
00E9:  MOVWF  77
00EA:  DECFSZ 77,F
00EB:  GOTO   0EA
00EC:  GOTO   0ED
00ED:  DECFSZ 00,F
00EE:  GOTO   0E1
00EF:  RETURN
.................... 
.................... // Pines para keypad-phone 4x3
.................... #define COL1 PIN_B0
.................... #define COL2 PIN_B1
.................... #define COL3 PIN_B2
.................... 
.................... #define ROW1 PIN_B3
.................... #define ROW2 PIN_B5
.................... #define ROW3 PIN_B6
.................... #define ROW4 PIN_B7
.................... 
.................... // LEDs
.................... #define LED_VERDE PIN_A0
.................... #define LED_ROJO  PIN_A1
.................... 
.................... volatile int8 toggle_flag = 0;
.................... volatile int  count = 0;
.................... // Timer0 ISR: se dispara cada ~10ms (configurado abajo)
.................... #INT_TIMER0
.................... void timer0_isr(void);
.................... void keypad_init(void);
.................... int keypad_get_key(void);
.................... void leds_off();
.................... void led_on(int led);
.................... 
.................... // Matriz de teclas
.................... const int keys[4][3] = {
....................    {1, 2, 3},
....................    {4, 5, 6},
....................    {7, 8, 9},
....................    {-2, 0, -3}  // '*' = -2, '0' = 0, '#' = -3
.................... };
.................... 
.................... 
.................... void main() {
00F0:  MOVLW  7A
00F1:  MOVLB  01
00F2:  MOVWF  19
00F3:  MOVLB  00
00F4:  CLRF   20
00F5:  CLRF   21
00F6:  MOVLB  03
00F7:  CLRF   0C
00F8:  CLRF   0D
00F9:  MOVLB  02
00FA:  CLRF   12
00FB:  CLRF   11
00FC:  CLRF   14
00FD:  CLRF   13
*
0105:  CLRF   25
0106:  MOVLW  FF
0107:  MOVWF  26
0108:  MOVWF  27
....................    int passwd[3] = {2, 5, 3};
*
00FE:  MOVLW  02
00FF:  MOVLB  00
0100:  MOVWF  22
0101:  MOVLW  05
0102:  MOVWF  23
0103:  MOVLW  03
0104:  MOVWF  24
....................    int index = 0;
....................    int key = -1;
....................    int last_key = -1;
....................    
....................    // Configuro Timer0
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256); // Prescaler 1:256
*
0109:  MOVLB  01
010A:  MOVF   15,W
010B:  ANDLW  C0
010C:  IORLW  07
010D:  MOVWF  15
....................    set_timer0(0);
010E:  MOVLB  00
010F:  CLRF   15
.................... 
....................    enable_interrupts(INT_TIMER0);
0110:  BSF    0B.5
....................    enable_interrupts(GLOBAL);
0111:  MOVLW  C0
0112:  IORWF  0B,F
....................    
....................    set_tris_a(0x00); // LEDs como salida
0113:  MOVLW  00
0114:  MOVLB  01
0115:  MOVWF  0C
....................    leds_off();
0116:  MOVLB  00
0117:  CALL   010
....................    keypad_init();
0118:  GOTO   01A
....................    
....................    while(TRUE) {
....................       key = keypad_get_key();
0119:  GOTO   054
011A:  MOVF   78,W
011B:  MOVWF  26
....................       
....................       //Esto es para el temporizador si es que se cuelga al apretar el siguiente boton
....................       if (toggle_flag && key == last_key) {
011C:  MOVF   20,F
011D:  BTFSC  03.2
011E:  GOTO   12B
011F:  MOVF   27,W
0120:  SUBWF  26,W
0121:  BTFSS  03.2
0122:  GOTO   12B
....................             index = 0;
0123:  CLRF   25
....................             toggle_flag = 0;
0124:  CLRF   20
....................             output_toggle(LED_ROJO);
0125:  MOVLB  01
0126:  BCF    0C.1
0127:  MOVLW  02
0128:  MOVLB  02
0129:  XORWF  0C,F
012A:  MOVLB  00
....................       }
....................       
....................       // se detecto la entrada de una nueva tecla detectada
....................       if(key != -1 && key != last_key) {  
012B:  MOVF   26,W
012C:  SUBLW  FF
012D:  BTFSC  03.2
012E:  GOTO   165
012F:  MOVF   27,W
0130:  SUBWF  26,W
0131:  BTFSC  03.2
0132:  GOTO   165
....................       count=0;
0133:  CLRF   21
....................       toggle_flag = 0;
0134:  CLRF   20
....................          if(key >= 0 && key <= 9) {  // Filtro que sea solo dígitos numericos
0135:  MOVF   26,W
0136:  SUBLW  09
0137:  BTFSS  03.0
0138:  GOTO   163
....................             if(key == passwd[index]) { //El boton que se apreto tiene que ver con la contraseña? 
0139:  MOVLW  02
013A:  ADDWF  25,W
013B:  MOVWF  04
013C:  MOVLW  20
013D:  MOVWF  05
013E:  BTFSC  03.0
013F:  INCF   05,F
0140:  MOVF   00,W
0141:  SUBWF  26,W
0142:  BTFSS  03.2
0143:  GOTO   156
....................                index++;
0144:  INCF   25,F
....................                if(index == 3) {  // Contraseña correcta completa
0145:  MOVF   25,W
0146:  SUBLW  03
0147:  BTFSS  03.2
0148:  GOTO   155
....................                   leds_off();
0149:  CALL   010
....................                   led_on(0); // Verde ON
014A:  CLRF   28
014B:  CALL   0C9
....................                   delay_ms(500);
014C:  MOVLW  02
014D:  MOVWF  28
014E:  MOVLW  FA
014F:  MOVWF  29
0150:  CALL   0DA
0151:  DECFSZ 28,F
0152:  GOTO   14E
....................                   leds_off();
0153:  CALL   010
....................                   index = 0;
0154:  CLRF   25
....................                }
....................             } else { // En caso de que el boton corresponda a un boton no apretado
0155:  GOTO   163
....................                leds_off();
0156:  CALL   010
....................                led_on(1); // Rojo ON
0157:  MOVLW  01
0158:  MOVWF  28
0159:  CALL   0C9
....................                delay_ms(500);
015A:  MOVLW  02
015B:  MOVWF  28
015C:  MOVLW  FA
015D:  MOVWF  29
015E:  CALL   0DA
015F:  DECFSZ 28,F
0160:  GOTO   15C
....................                leds_off();
0161:  CALL   010
....................                index = 0;
0162:  CLRF   25
....................             }
....................          }
....................          last_key = key;
0163:  MOVF   26,W
0164:  MOVWF  27
....................       }
....................       
....................       if(key == -1) last_key = -1; // Esperar a que se suelte la tecla
0165:  MOVF   26,W
0166:  SUBLW  FF
0167:  BTFSS  03.2
0168:  GOTO   16B
0169:  MOVLW  FF
016A:  MOVWF  27
....................       
....................       delay_ms(50);
016B:  MOVLW  32
016C:  MOVWF  29
016D:  CALL   0DA
016E:  GOTO   119
....................    }
.................... }
.................... 
016F:  SLEEP
.................... 
.................... void timer0_isr() {
....................     count++;
....................     if (count >= 100) {   // 50 * 10ms = 500ms
....................         toggle_flag = 1; // Indica que hay que togglear el led
....................         count = 0;
....................     }
.................... }
.................... 
.................... 
.................... 
.................... // Inicializar keypad (filas salida, columnas entrada)
.................... void keypad_init() {
....................    // Ahora B0,B1,B2 inputs, B3,B5,B6,B7 outputs
....................    set_tris_b(0b11110001); 
*
001A:  MOVLW  F1
001B:  MOVLB  01
001C:  MOVWF  0D
....................    // B7 B6 B5 B4 B3 B2 B1 B0
....................    //  1  1  1  1  0  0  0  1  (B3=0 salida, B4=1 entrada)
....................    output_high(ROW1);
001D:  BCF    0D.3
001E:  MOVLB  02
001F:  BSF    0D.3
....................    output_high(ROW2);
0020:  MOVLB  01
0021:  BCF    0D.5
0022:  MOVLB  02
0023:  BSF    0D.5
....................    output_high(ROW3);
0024:  MOVLB  01
0025:  BCF    0D.6
0026:  MOVLB  02
0027:  BSF    0D.6
....................    output_high(ROW4);
0028:  MOVLB  01
0029:  BCF    0D.7
002A:  MOVLB  02
002B:  BSF    0D.7
002C:  MOVLP  00
002D:  MOVLB  00
002E:  GOTO   119 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... // Leer tecla pulsada, -1 si no hay, o el valor de la tecla
.................... int keypad_get_key() {
....................    int row, col;
....................    
....................    for(row=0; row<4; row++) {
*
0054:  CLRF   28
0055:  MOVF   28,W
0056:  SUBLW  03
0057:  BTFSS  03.0
0058:  GOTO   0BD
....................       // Poner todas las filas en alto (no activas)
....................       output_high(ROW1);
0059:  MOVLB  01
005A:  BCF    0D.3
005B:  MOVLB  02
005C:  BSF    0D.3
....................       output_high(ROW2);
005D:  MOVLB  01
005E:  BCF    0D.5
005F:  MOVLB  02
0060:  BSF    0D.5
....................       output_high(ROW3);
0061:  MOVLB  01
0062:  BCF    0D.6
0063:  MOVLB  02
0064:  BSF    0D.6
....................       output_high(ROW4);
0065:  MOVLB  01
0066:  BCF    0D.7
0067:  MOVLB  02
0068:  BSF    0D.7
....................       
....................       // Activar una fila poniendola en bajo
....................       switch(row) {
0069:  MOVLB  00
006A:  MOVF   28,W
006B:  ADDLW  FC
006C:  BTFSC  03.0
006D:  GOTO   087
006E:  ADDLW  04
006F:  GOTO   0C1
....................          case 0: output_low(ROW1); break;
0070:  MOVLB  01
0071:  BCF    0D.3
0072:  MOVLB  02
0073:  BCF    0D.3
0074:  MOVLB  00
0075:  GOTO   087
....................          case 1: output_low(ROW2); break;
0076:  MOVLB  01
0077:  BCF    0D.5
0078:  MOVLB  02
0079:  BCF    0D.5
007A:  MOVLB  00
007B:  GOTO   087
....................          case 2: output_low(ROW3); break;
007C:  MOVLB  01
007D:  BCF    0D.6
007E:  MOVLB  02
007F:  BCF    0D.6
0080:  MOVLB  00
0081:  GOTO   087
....................          case 3: output_low(ROW4); break;
0082:  MOVLB  01
0083:  BCF    0D.7
0084:  MOVLB  02
0085:  BCF    0D.7
0086:  MOVLB  00
....................       }
....................       delay_us(20);
0087:  MOVLW  1A
0088:  MOVWF  77
0089:  DECFSZ 77,F
008A:  GOTO   089
008B:  NOP
....................       
....................       // Leer columnas
....................       if(!input(COL1)) return keys[row][0];
008C:  MOVLB  01
008D:  BSF    0D.0
008E:  MOVLB  00
008F:  BTFSC  0D.0
0090:  GOTO   09B
0091:  MOVF   28,W
0092:  MOVWF  2A
0093:  MOVLW  03
0094:  MOVWF  2B
0095:  CALL   02F
0096:  MOVF   78,W
0097:  CALL   003
0098:  MOVWF  78
0099:  MOVWF  78
009A:  GOTO   0BF
....................       if(!input(COL2)) return keys[row][1];
009B:  MOVLB  01
009C:  BSF    0D.1
009D:  MOVLB  00
009E:  BTFSC  0D.1
009F:  GOTO   0AB
00A0:  MOVF   28,W
00A1:  MOVWF  2A
00A2:  MOVLW  03
00A3:  MOVWF  2B
00A4:  CALL   02F
00A5:  MOVLW  01
00A6:  ADDWF  78,W
00A7:  CALL   003
00A8:  MOVWF  78
00A9:  MOVWF  78
00AA:  GOTO   0BF
....................       if(!input(COL3)) return keys[row][2];
00AB:  MOVLB  01
00AC:  BSF    0D.2
00AD:  MOVLB  00
00AE:  BTFSC  0D.2
00AF:  GOTO   0BB
00B0:  MOVF   28,W
00B1:  MOVWF  2A
00B2:  MOVLW  03
00B3:  MOVWF  2B
00B4:  CALL   02F
00B5:  MOVLW  02
00B6:  ADDWF  78,W
00B7:  CALL   003
00B8:  MOVWF  78
00B9:  MOVWF  78
00BA:  GOTO   0BF
00BB:  INCF   28,F
00BC:  GOTO   055
....................    }
....................    return -1;
00BD:  MOVLW  FF
00BE:  MOVWF  78
00BF:  MOVLP  00
00C0:  GOTO   11A (RETURN)
.................... }
.................... 
.................... 
.................... // Apagar ambos LEDs
.................... void leds_off() {
....................    output_low(LED_VERDE);
*
0010:  MOVLB  01
0011:  BCF    0C.0
0012:  MOVLB  02
0013:  BCF    0C.0
....................    output_low(LED_ROJO);
0014:  MOVLB  01
0015:  BCF    0C.1
0016:  MOVLB  02
0017:  BCF    0C.1
0018:  MOVLB  00
0019:  RETURN
.................... }
.................... 
.................... // Encender LED verde o rojo (led=0 verde, led=1 rojo)
.................... void led_on(int led) {
....................    if(led == 0) output_high(LED_VERDE);
*
00C9:  MOVF   28,F
00CA:  BTFSS  03.2
00CB:  GOTO   0D2
00CC:  MOVLB  01
00CD:  BCF    0C.0
00CE:  MOVLB  02
00CF:  BSF    0C.0
00D0:  GOTO   0D8
00D1:  MOVLB  00
....................    else if(led == 1) output_high(LED_ROJO);
00D2:  DECFSZ 28,W
00D3:  GOTO   0D8
00D4:  MOVLB  01
00D5:  BCF    0C.1
00D6:  MOVLB  02
00D7:  BSF    0C.1
00D8:  MOVLB  00
00D9:  RETURN
.................... }

Configuration Fuses:
   Word  1: 39A4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
